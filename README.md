# Binomial-Asset-Pricing-Model
In this project, we will be breaking down the theory described and published in Steven Shreve’s book’s Stochastic Calculus for Finance I & II. As a guide for implementing these concepts in Python, we will refer to the numerical methods and practices outlined in Les Clewlow & Chris Strickland’s book Implementing Derivatives Models. 

We will go through two implementations of a simple binomial tree model in Python, one that will use ‘for loops’ to step through each node at each time step (a function I have defined as binomial tree slow), and the other (binomial tree fast) will vectorize these steps using numpy arrays, improving overall computation time as N time steps increase. Although not necessary for python notebook 'Binomial_Option_Pricing_Model.ipynb', using numpy arrays and vectorizing our calculations will improve computations as we delve deeper into financial mathematics and implementation heading forward.

We look at pricing Barrier Options using the Binomial Asset Pricing Model and see how we can implement the barrier tree model to price an up-and-out barrier option in Python. There are two types of barrier options which we look at in 'Barrier_Options_with_Binomial_Trees.ipynb', up-and-out barrier options and down-and-out barrier options. Here we go through the theory and implementation. We'll go through two implementations of a simple barrier tree model in Python, one that will use ‘for loops’ to step through each node at each time step (a function I have defined as binomial tree slow), and the other (binomial tree fast) will vectorize these steps using numpy arrays, improving overall computation time as N time steps increase. Although not necessary for python notebook 'Barrier_Options_with_Binomial_Trees.ipynb', using numpy arrays and vectorizing our calculations will improve computations as we delve deeper into financial mathematics and implementation heading forward.

We look at pricing American Options using the Binomial Asset Pricing Model and see how we can implement the binomial tree model to price an American option in Python in 'American_Option_Pricing_with_Binomial_Trees.ipynb' notebook. We also see why it is not optimal to early exercise an American Call option with no dividend (or positive interest rates). 

In 'Choosing_Binomial_Parameters.ipynb' we look at pricing a European Call option using the Binomial Asset Pricing Model with four different methods to define the binomial parameters in Python. Here we explore four methods to choose the binomial tree parameters up-factor u, down-factor d and risk-neutral probability q. All methods attempt to approximate the risk-neutral asset dynamics as accurately as possible; this is done by matching the mean and variance of the binomial asset pricing model to the dynamics of the underlying - Geometric Brownian Motion (GBM). The Cox, Ross and Rubinstein (CRR) method assumes that the up and down factors have the same jump size while the Jarrow and Rudd (JR) method assumes the same risk-neutral probabilities. 

If the underlying binomial tree is represented in terms of the natural logarithm of asset prices (where x=ln(S)) then the risk-neutral dynamics of the black-scholes model can be used for accurate and robust approximation. Using the GBM, the log-normal distribution has constant mean and variance and hence the mean and variance is easy to match with that of the binomial tree model. The Equal Probability method (EQP) proposed exactly that, using equal probabilities with the underlying tree represented by the natural logarithm of asset prices. The Trigeorgis method (TRG) is again represented by equal jump sizes, however implemented on a binomial tree represented by the natural logarithm of asset prices.
